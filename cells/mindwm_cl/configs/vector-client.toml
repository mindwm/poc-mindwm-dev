data_dir = "${HOME}/.local/mindwm/vector"

# Pipe bytestream from TMUX
# sanitize control sequences
# and publish clean word to MindWM backend
[sources.tmux_udp]
address = "${MINDWM_CLIENT_VECTOR_UDP_BIND}:${MINDWM_CLIENT_VECTOR_UDP_PORT}"
mode = "udp"
type = "socket"
decoding.codec = "bytes"

[transforms.byte_or_chunk]
type = "route"
inputs = [ "tmux_udp" ]
route.one_byte = 'length(to_string!(.message)) == 1'
route.chunk = 'length(to_string!(.message)) > 1'

[transforms.tmux_words]
inputs = ["byte_or_chunk.one_byte"]
type = "reduce"
ends_when = """
  .message == " " || .message == "\t" || .message == "\r" || .message == "\n"
"""
merge_strategies.message = "concat_raw"

[transforms.tmux_chunk]
inputs = [ "byte_or_chunk.chunk" ]
type = "remap"
source = """
  clean = strip_ansi_escape_codes!(.message)
  words = split(clean, r'[[:space:]]')
  . = filter(words) -> |_i, v| { v != "" }
"""

# enrich with metadata
[transforms.with_meta]
type = "remap"
inputs = [ "tmux_words", "tmux_chunk" ]
source = """
.knativebrokerttl = "255"
.specversion = "1.0"
.type = "word"
.source = "ping.snpnb"
.subject = "pion.snpnb.tmux.L3RtcC90bXV4LTEwMDAvZGVmYXVsdAo=.1981756.0.2.words"
.datacontenttype = "application/json"
.data.word = del(.message)
"""

# publish to MindWM backend
[sinks.back_nats_words]
inputs = [ "with_meta" ]
type = "nats"
subject = "${MINDWM_BACK_NATS_SUBJECT_WORDS_IN}"
url = "nats://${MINDWM_BACK_NATS_HOST}:${MINDWM_BACK_NATS_PORT}"
encoding.codec = "json"
auth.strategy = "user_password"
auth.user_password.user = "${MINDWM_BACK_NATS_USER}"
auth.user_password.password = "${MINDWM_BACK_NATS_PASS}"


[sinks.debug]
inputs = ["with_meta"]
#inputs = [""]
type = "console"
encoding.codec = "json"
